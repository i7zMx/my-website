<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arrays and Matrices in Python</title>
	<link rel="stylesheet" href="style.css">
	<script src="script.js"></script>
</head>
<body>
    <header>
        <h1>Arrays and Matrices in Python</h1>
        <p>Understanding arrays and matrices: implementations, operations, and best practices</p>
    </header>
    
    <div class="container">
        <div class="toc">
            <h2>Contents</h2>
            <ul>
                <li><a href="#introduction">1. Introduction</a></li>
                <li><a href="#comparison">2. Arrays using Array Module vs NumPy Arrays vs Matrices</a></li>
                <li><a href="#operations">3. How Processing Works with Each (Operations)</a></li>
                <li><a href="#examples">4. Code Examples</a></li>
                    <div class="subsection">
                        <li><a href="#creating">Creating Arrays and Matrices</a></li>
                        <li><a href="#basic-operations">Basic Operations</a></li>
                    </div>
                <li><a href="#summary">5. Summary</a></li>
            </ul>
        </div>
        
        <section id="introduction">
            <h2>1. Introduction</h2>
            <p>Arrays and matrices are fundamental data structures in scientific computing and data analysis. They provide efficient storage and manipulation of numeric data, especially for mathematical operations.</p>
            
            <div class="note">
                <strong>Why Learn About Arrays and Matrices?</strong> Understanding these structures is essential for data science, machine learning, scientific computing, and many other fields that require efficient numerical computations.
            </div>
            
            <div class="visual-container">
                <div class="visual-card">
                    <h4>Arrays</h4>
                    <p>One-dimensional ordered collections of elements of the same type.</p>
                    <div class="matrix-visual">
                        [1, 2, 3, 4, 5]
                    </div>
                </div>
                
                <div class="visual-card">
                    <h4>Matrices</h4>
                    <p>Two-dimensional ordered collections arranged in rows and columns.</p>
                    <div class="matrix-visual">
                        [1, 2, 3]<br>
                        [4, 5, 6]<br>
                        [7, 8, 9]
                    </div>
                </div>
                
                <div class="visual-card">
                    <h4>Key Concepts</h4>
                    <ul style="text-align: left;">
                        <li>Shape and dimensions</li>
                        <li>Element-wise operations</li>
                        <li>Matrix operations</li>
                        <li>Memory efficiency</li>
                    </ul>
                </div>
            </div>
            
            <h3>What is an Array?</h3>
            <p>An array is a collection of items stored at contiguous memory locations. The idea is to store multiple items of the same type together in a systematic way. This makes it easier to calculate the position of each element by simply adding an offset to a base value.</p>
            
            <p>Arrays provide several key advantages:</p>
            <ul>
                <li>Efficient memory usage with fixed size allocation</li>
                <li>Fast access to elements using indices (constant time complexity)</li>
                <li>Simple mathematical operations across all elements</li>
                <li>Vectorized operations that avoid explicit loops</li>
            </ul>
            
            <h3>What is a Matrix?</h3>
            <p>A matrix is a two-dimensional array where data is arranged in rows and columns. It's commonly used in mathematical and scientific applications to represent linear transformations, solve systems of linear equations, and analyze data structures.</p>
            
            <p>Matrices are fundamental in:</p>
            <ul>
                <li>Linear algebra computations</li>
                <li>Computer graphics and 3D transformations</li>
                <li>Solving systems of equations</li>
                <li>Data analysis and machine learning algorithms</li>
                <li>Signal processing and image manipulation</li>
            </ul>
            
            <h3>The Python Ecosystem for Arrays and Matrices</h3>
            <p>Python offers multiple implementations for working with arrays and matrices, each with different advantages:</p>
            <ul>
                <li>Python's built-in lists (general purpose, but not optimized for numerical operations)</li>
                <li>The <code>array</code> module in the standard library (more memory efficient than lists)</li>
                <li>NumPy arrays (highly optimized for numerical operations)</li>
                <li>NumPy matrix objects (specialized for linear algebra operations)</li>
            </ul>
        </section>
        
        <section id="comparison">
            <h2>2. Arrays using Array Module vs NumPy Arrays vs Matrices</h2>
            
            <p>Python offers several ways to work with arrays and matrices. The three main approaches are:</p>
            
            <div class="operation-example">
                <h3>Python's Built-in Array Module</h3>
                <p>The <code>array</code> module provides a space-efficient array implementation that holds items of the same data type.</p>
                <ul>
                    <li>Efficient for storing primitive data types</li>
                    <li>Limited mathematical functionality</li>
                    <li>One-dimensional only</li>
                </ul>
            </div>
            
            <div class="operation-example">
                <h3>NumPy Arrays (ndarray)</h3>
                <p>NumPy's n-dimensional array is the core data structure for scientific computing in Python.</p>
                <ul>
                    <li>Highly efficient multi-dimensional array</li>
                    <li>Rich set of mathematical operations</li>
                    <li>Optimized for numerical computations</li>
                    <li>Flexible broadcasting capabilities</li>
                </ul>
            </div>
            
            <div class="operation-example">
                <h3>NumPy Matrices</h3>
                <p>NumPy also provides a specialized matrix class that is a subclass of ndarray.</p>
                <ul>
                    <li>Always 2-dimensional</li>
                    <li>Different operator behavior (e.g., * for matrix multiplication)</li>
                    <li>Specialized methods for matrix operations</li>
                    <li>Being phased out in favor of ndarray with @ operator</li>
                </ul>
            </div>
            
            <div class="warning">
                <strong>Important Note:</strong> The NumPy <code>matrix</code> class is being phased out in favor of using regular NumPy arrays with the <code>@</code> operator for matrix multiplication. New code should prefer NumPy arrays over matrices.
            </div>
            
            <h3>Comparison Table</h3>
            <table class="comparison-table">
                <tr>
                    <th>Feature</th>
                    <th>Python Array</th>
                    <th>NumPy Array</th>
                    <th>NumPy Matrix</th>
                </tr>
                <tr>
                    <td>Dimensions</td>
                    <td>1D only</td>
                    <td>N-dimensional</td>
                    <td>2D only</td>
                </tr>
                <tr>
                    <td>Data Types</td>
                    <td>Homogeneous, limited types</td>
                    <td>Homogeneous, extensive types</td>
                    <td>Homogeneous, extensive types</td>
                </tr>
                <tr>
                    <td>Mathematical Operations</td>
                    <td>Basic arithmetic</td>
                    <td>Element-wise operations by default</td>
                    <td>Matrix operations by default</td>
                </tr>
                <tr>
                    <td>Memory Efficiency</td>
                    <td>High</td>
                    <td>High</td>
                    <td>High</td>
                </tr>
                <tr>
                    <td>Convenience for Linear Algebra</td>
                    <td>Low</td>
                    <td>Medium</td>
                    <td>High</td>
                </tr>
                <tr>
                    <td>Future Support</td>
                    <td>Stable</td>
                    <td>Active development</td>
                    <td>Being phased out</td>
                </tr>
            </table>
        </section>
        
        <section id="operations">
            <h2>3. How Processing Works with Each (Operations)</h2>
            
            <h3>Array Module Operations</h3>
            <p>Python's built-in array module supports basic operations:</p>
            <ul>
                <li><strong>Creation:</strong> Arrays are created with a type code specifying the data type</li>
                <li><strong>Element Access:</strong> Individual elements accessed via indexing</li>
                <li><strong>Concatenation:</strong> Arrays can be concatenated using the + operator</li>
                <li><strong>Repetition:</strong> Arrays can be repeated using the * operator</li>
                <li><strong>No direct support for:</strong> Matrix operations, element-wise calculations, or complex math</li>
            </ul>
            
            <div class="note">
                <strong>Array Type Codes:</strong> When creating arrays with the <code>array</code> module, you must specify a type code. Common type codes include 'i' for integers, 'f' for floats, and 'd' for doubles.
            </div>
            
            <h3>NumPy Array Operations</h3>
            <p>NumPy arrays offer comprehensive mathematical operations:</p>
            <ul>
                <li><strong>Element-wise operations:</strong> <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> operate element-by-element</li>
                <li><strong>Broadcasting:</strong> Automatically handles operations between arrays of different shapes</li>
                <li><strong>Matrix multiplication:</strong> Using <code>@</code> operator or <code>dot()</code> function</li>
                <li><strong>Advanced indexing:</strong> Slicing, boolean indexing, and fancy indexing</li>
                <li><strong>Universal functions:</strong> Fast element-wise operations like <code>np.sin()</code>, <code>np.exp()</code></li>
                <li><strong>Aggregation:</strong> Functions like <code>sum()</code>, <code>mean()</code>, <code>max()</code></li>
            </ul>
            
            <h3>NumPy Matrix Operations</h3>
            <p>NumPy Matrix class is specialized for linear algebra:</p>
            <ul>
                <li><strong>Matrix multiplication:</strong> <code>*</code> operator performs matrix multiplication (not element-wise)</li>
                <li><strong>Transposition:</strong> <code>.T</code> attribute transposes the matrix</li>
                <li><strong>Inverse:</strong> <code>I</code> attribute computes the inverse</li>
                <li><strong>Element-wise operations:</strong> Require explicit functions like <code>multiply()</code></li>
                <li><strong>Linear algebra:</strong> Optimized for solving linear systems, eigenvalue problems, etc.</li>
            </ul>
            
            <div class="visual-container">
                <div class="visual-card">
                    <h4>Element-wise Operation</h4>
                    <div class="matrix-visual">
                        [1, 2, 3] + [4, 5, 6] =<br>
                        [5, 7, 9]
                    </div>
                    <p>Each element is processed independently</p>
                </div>
                
                <div class="visual-card">
                    <h4>Matrix Multiplication</h4>
                    <div class="matrix-visual">
								A&ensp;&ensp;&ensp;&ensp;&ensp;B <br>
                            [1, 2]&ensp;[5, 6]    <br>
                            [3, 4]&ensp;[7, 8]	  <br>
									A x B 		  <br>
									[19, 22]      <br>
									[43, 50]
                    </div>
                    <p>Rows × columns with summation</p>
                </div>
                
                <div class="visual-card">
                    <h4>Broadcasting</h4>
                    <div class="matrix-visual">
                        [1, 2, 3] * 2 =<br>
                        [2, 4, 6]
                    </div>
                    <p>Scalar operations applied to all elements</p>
                </div>
            </div>
            
            <h3>Performance Comparison</h3>
            <p>NumPy arrays significantly outperform Python's built-in array module for numerical operations because:</p>
            <ul>
                <li>They're implemented in C for maximum speed</li>
                <li>They take advantage of vectorized operations</li>
                <li>They can utilize SIMD (Single Instruction, Multiple Data) instructions</li>
                <li>They optimize memory access patterns</li>
            </ul>
            
            <div class="note">
                <strong>Broadcasting:</strong> NumPy's broadcasting is a powerful mechanism that allows arrays with different shapes to be used in operations. It automatically "broadcasts" the smaller array across the larger one so they have compatible shapes.
            </div>
        </section>
        
        <section id="examples">
            <h2>4. Code Examples</h2>
            
            <h3 id="creating">Creating Arrays and Matrices</h3>
            
            <div class="code-block">
                <div class="code-header">
                    <span>Creating Arrays and Matrices (Click to Expand)</span>
                    <span class="code-toggle">▼</span>
                </div>
                <div class="code-content">
                    <pre>
import array

# Creating an array of integers
arr = array.array('i', [1, 2, 3, 4, 5])
print("Array created using array module:", arr)

# Accessing elements
print("First element:", arr[0])
print("Last element:", arr[-1])

# Modifying elements
arr[2] = 10
print("Modified array:", arr)

print("#--------------------------------------\n")
import numpy as np

# Creating a 1D array
arr = np.array([1, 2, 3, 4, 5])
print("1D numpy array:", arr)

# Creating a 2D array (matrix)
matrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print("2D numpy array (matrix):\n", matrix)

# Accessing elements
print("Element at (0, 0):", matrix[0, 0])
print("Element at (2, 2):", matrix[2, 2])

# Slicing arrays
print("First row:", matrix[0, :])
print("Second column:", matrix[:, 1])

# Modifying elements
matrix[1, 1] = 10
print("Modified matrix:\n", matrix)

print("#--------------------------------------\n")
import numpy as np
# Creating a matrix using np.matrix
mat = np.matrix([[1, 2], [3, 4]])
print("Matrix created using np.matrix:\n", mat)

# Matrix multiplication
mat2 = np.matrix([[5, 6], [7, 8]])
result = mat * mat2
print("Matrix multiplication result:\n", result)

# Transpose of a matrix
transpose_mat = mat.T
print("Transpose of the matrix:\n", transpose_mat)

# Inverse of a matrix
inverse_mat = np.linalg.inv(mat)
print("Inverse of the matrix:\n", inverse_mat)
                    </pre>
                    <div class="code-output">
Array created using array module: array('i', [1, 2, 3, 4, 5])
First element: 1
Last element: 5
Modified array: array('i', [1, 2, 10, 4, 5])
#--------------------------------------
1D numpy array: [1 2 3 4 5]
2D numpy array (matrix):
 [[1 2 3]
 [4 5 6]
 [7 8 9]]
Element at (0, 0): 1
Element at (2, 2): 9
First row: [1 2 3]
Second column: [2 5 8]
Modified matrix:
 [[ 1  2  3]
 [ 4 10  6]
 [ 7  8  9]]
#--------------------------------------
Matrix created using np.matrix:
 [[1 2]
 [3 4]]
Matrix multiplication result:
 [[19 22]
 [43 50]]
Transpose of the matrix:
 [[1 3]
 [2 4]]
Inverse of the matrix:
 [[-2.   1. ]
 [ 1.5 -0.5]]
                    </div>
                </div>
            </div>
            
            <h3 id="basic-operations">Basic Operations with Arrays And Matrices</h3>
            
            <div class="code-block">
                <div class="code-header">
                    <span>Basic Operations with Arrays And Matrices (Click to Expand)</span>
                    <span class="code-toggle">▼</span>
                </div>
                <div class="code-content">
                    <pre>
import array

# Create an array of integers
arr = array.array('i', [1, 2, 3, 4, 5])

# Accessing elements
print("First element:", arr[0])
print("Last element:", arr[-1])

# Appending an element
arr.append(6)
print("After appending 6:", arr)

# Slicing the array
sliced_arr = arr[1:4]
print("Sliced array (1:4):", sliced_arr)

# Modifying an element
arr[2] = 10
print("After modifying index 2:", arr)

# Element-wise addition (manual loop)
for i in range(len(arr)):
    arr[i] += 1
print("After adding 1 to each element:", arr)

print("#--------------------------------------\n")

import numpy as np

# Create a 1D numpy array
arr = np.array([1, 2, 3, 4, 5])
print("1D numpy array:", arr)

# Create a 2D numpy array (matrix)
matrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print("2D numpy array (matrix):\n", matrix)

# Element-wise operations
print("Add 2 to each element:\n", matrix + 2)
print("Multiply each element by 2:\n", matrix * 2)

# Matrix operations
matrix2 = np.array([[9, 8, 7], [6, 5, 4], [3, 2, 1]])
print("Matrix addition:\n", matrix + matrix2)
print("Matrix multiplication (element-wise):\n", matrix * matrix2)

# Dot product (matrix multiplication)
dot_product = np.dot(matrix, matrix2)
print("Dot product (matrix multiplication):\n", dot_product)

# Transpose of a matrix
transpose = matrix.T
print("Transpose of the matrix:\n", transpose)

# Reshaping the array
reshaped = matrix.reshape(1, 9)
print("Reshaped matrix (1x9):\n", reshaped)

# Sum of all elements
print("Sum of all elements:", matrix.sum())

# Sum along rows and columns
print("Sum along rows (axis=0):", matrix.sum(axis=0))
print("Sum along columns (axis=1):", matrix.sum(axis=1))

print("#--------------------------------------\n")

import numpy as np

# Create a matrix using np.matrix
mat = np.matrix([[1, 2], [3, 4]])
print("Matrix:\n", mat)

# Matrix multiplication
mat2 = np.matrix([[5, 6], [7, 8]])
result = mat * mat2
print("Matrix multiplication:\n", result)

# Transpose of a matrix
transpose_mat = mat.T
print("Transpose of the matrix:\n", transpose_mat)

# Inverse of a matrix
inverse_mat = np.linalg.inv(mat)
print("Inverse of the matrix:\n", inverse_mat)

# Determinant of a matrix
determinant = np.linalg.det(mat)
print("Determinant of the matrix:", determinant)

# Eigenvalues and eigenvectors
eigenvalues, eigenvectors = np.linalg.eig(mat)
print("Eigenvalues:", eigenvalues)
print("Eigenvectors:\n", eigenvectors)

                    </pre>
                    <div class="code-output">
First element: 1
Last element: 5
After appending 6: array('i', [1, 2, 3, 4, 5, 6])
Sliced array (1:4): array('i', [2, 3, 4])
After modifying index 2: array('i', [1, 2, 10, 4, 5, 6])
After adding 1 to each element: array('i', [2, 3, 11, 5, 6, 7])
#--------------------------------------
1D numpy array: [1 2 3 4 5]
2D numpy array (matrix):
 [[1 2 3]
 [4 5 6]
 [7 8 9]]
Add 2 to each element:
 [[ 3  4  5]
 [ 6  7  8]
 [ 9 10 11]]
Multiply each element by 2:
 [[ 2  4  6]
 [ 8 10 12]
 [14 16 18]]
Matrix addition:
 [[10 10 10]
 [10 10 10]
 [10 10 10]]
Matrix multiplication (element-wise):
 [[ 9 16 21]
 [24 25 24]
 [21 16  9]]
Dot product (matrix multiplication):
 [[ 30  24  18]
 [ 84  69  54]
 [138 114  90]]
Transpose of the matrix:
 [[1 4 7]
 [2 5 8]
 [3 6 9]]
Reshaped matrix (1x9):
 [[1 2 3 4 5 6 7 8 9]]
Sum of all elements: 45
Sum along rows (axis=0): [12 15 18]
Sum along columns (axis=1): [ 6 15 24]
#--------------------------------------
Matrix:
 [[1 2]
 [3 4]]
Matrix multiplication:
 [[19 22]
 [43 50]]
Transpose of the matrix:
 [[1 3]
 [2 4]]
Inverse of the matrix:
 [[-2.   1. ]
 [ 1.5 -0.5]]
Determinant of the matrix: -2.0000000000000004
Eigenvalues: [-0.37228132  5.37228132]
Eigenvectors:
 [[-0.82456484 -0.41597356]
 [ 0.56576746 -0.90937671]]
                    </div>
                </div>
            </div>
            
            <div class="note">
                <strong>Common Applications:</strong>
                <ul>
                    <li><strong>Data Analysis:</strong> Processing tabular data, statistics, and transformations</li>
                    <li><strong>Machine Learning:</strong> Feature matrices, weight vectors, and computational graphs</li>
                    <li><strong>Image Processing:</strong> Images as 2D or 3D arrays with pixel values</li>
                    <li><strong>Scientific Computing:</strong> Simulations, differential equations, and numerical methods</li>
                </ul>
            </div>
        </section>
        
        <section id="summary">
            <h2>5. Summary</h2>
            
            <div class="operation-example">
                <h3>Key Differences</h3>
                <p>Python's built-in array module, NumPy's ndarray, and NumPy's matrix class offer different capabilities that make each suitable for different applications:</p>
                <ul>
                    <li>Python <span class="highlight">array module</span> is best for simple, memory-efficient 1D collections of primitive types.</li>
                    <li>NumPy <span class="highlight">ndarray</span> is versatile and powerful for any numerical computing task, supporting n-dimensions.</li>
                    <li>NumPy <span class="highlight">matrix</span> class is specialized for linear algebra operations, though it's being phased out.</li>
                </ul>
            </div>
            
            <div class="operation-example">
                <h3>Best Practices</h3>
                <ul>
                    <li>Use NumPy arrays for most scientific computing and data analysis tasks.</li>
                    <li>Prefer NumPy arrays over matrices, as matrices are being deprecated.</li>
                    <li>Use <code>@</code> operator or <code>dot()</code> for matrix multiplication with NumPy arrays.</li>
                    <li>Take advantage of broadcasting for concise and efficient code.</li>
                    <li>Vectorize operations whenever possible instead of using loops.</li>
                </ul>
            </div>
            
            <div class="operation-example">
                <h3>Performance Considerations</h3>
                <ul>
                    <li>NumPy operations are implemented in C and are much faster than Python loops.</li>
                    <li>Memory layout matters: contiguous arrays are faster to process.</li>
                    <li>For very large datasets, consider specialized libraries built on NumPy like Pandas, Dask, or Xarray.</li>
                    <li>Avoid unnecessary copying of large arrays.</li>
                </ul>
            </div>
            
            <div class="operation-example">
                <h3>When to Choose Each Option</h3>
                <ul>
                    <li><strong>Python's array module:</strong> When you need a simple memory-efficient collection of primitive types without complex operations.</li>
                    <li><strong>NumPy arrays:</strong> For most scientific computing and data analysis needs, especially when flexibility and performance matter.</li>
                    <li><strong>NumPy matrices:</strong> Only for legacy code that specifically requires matrix semantics.</li>
                </ul>
            </div>
            
            <p>In conclusion, NumPy arrays strike the best balance between functionality, performance, and future support. For most applications, they should be your default choice, with matrices being useful for certain mathematical operations but increasingly replaced by array operations with the appropriate functions or operators.</p>
        </section>
    <a href="#" class="back-to-top">↑</a>
    
    <footer>
        <p>© 2025 Arrays and Matrices in Python | Created with HTML,CSS And Javascript</p>
    </footer>
</body>
</html>
